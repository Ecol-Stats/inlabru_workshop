---
title: ""
format: 
  html:
    theme:
      light: flatly
      dark: darkly
  PrettyPDF-pdf:
    keep-tex: true
    number-sections: true
embed-resources: true
editor_options: 
  chunk_output_type: console
---

```{r test}
#| message: false
#| warning: false
#| echo: false
library(webexercises)
# For plotting
library(mapview)
library(ggplot2)
library(scico) # for colouring palettes
library(patchwork)
library(terra)
library(sf)
# Data manipulation
library(dplyr)
library(fmesher)
library(INLA)
library(inlabru)
library(viridis)
library(gt)
```

## Point process data

In this practical we are going to fit a log Gaussian Cox Proces (LGCP) model to point-referenced data. We will:


-   Learn how to fit a LGCP model in `inlabru`

-   Learn how to add spatial covariates to the model

-   Learn how to do predictions


In **point processes** we measure the locations where events occur (e.g. trees in a forest, earthquakes) and the coordinates of such occurrences are our data. A spatial point process is a random variable operating in continuous space, and we observe realisations of this variable as point patterns across space.

Consider a fixed geographical region $A$. The set of locations at which events occur are denoted $\mathbf{s} = s_1,\ldots,s_n$. We let $N(A)$ be the random variable which represents the number of events in region $A$.

We typically assume that a spatial point pattern is generated by an unique point process over the whole study area. This means that the delimitation of the study area will affect the observed point patters.

We can define the intensity of a point process as the expected number of events per unit area. This can also be thought of as a measure of the density of our points. In some cases, the intensity will be constant over space (homogeneous), while in other cases it can vary by location (inhomogeneous or heterogenous).

In the next example we will be looking at butterflies occurrence records obtained from the *Butterflies for the New Millennium* (BNM) monitoring scheme. The data set consists of Ringlet butterfly's presence-only records collected by volunteers in Scotland's Cairngorms National Park (CNP).

### Point-referenced data visualization

Let's begin by loading the data which can be downloaded below:

 {{< downloadthis datasets/ringlett_CNP.RData dname="ringlett_CNP" label="Download ringlett data set" icon="database-fill-down" type="info" >}}

 {{< downloadthis datasets/elev_CNP.tiff dname="elev_CNP" label="Download raster data" icon="database-fill-down" >}}
 
```{r}
# load data files (set the correct path to where the data are stored)
load("datasets/ringlett_CNP.RData")
elev_rast = terra::rast("datasets/elev_CNP.tiff")
```

Then, we load the geographical region of interest which can be downloaded [here](https://maps.gov.scot/ATOM/shapefiles/SG_CairngormsNationalPark_2010.zip) (i.e., CNP boundaries). We can use thre `st_read` function from the `sf` library to load the `.shp` file by specifying the directory where you downloaded the files. For example,

```{r}
shp_SGC <-  st_read("datasets/SG_CairngormsNationalPark/SG_CairngormsNationalPark_2010.shp",quiet =T)
```

We need to set an appropriate CRS for our shapefile:

```{r}
shp_SGC <- shp_SGC %>% st_transform(crs = 27700)
shp_SGC <- st_transform(shp_SGC,gsub("units=m","units=km",st_crs(shp_SGC)$proj4string)) 

```

We can then visually verify the projections by plotting the observation records against the spatial domain of interest as follows:

```{r}
#| code-fold: true
#| fig-align: center
#| fig-width: 5
#| fig-height: 5
ggplot()+
  geom_sf(data=shp_SGC)+
  geom_sf(data=ringlett_CNP,size=2)
```

::: {.callout-warning icon="false"}
## {{< bi pencil-square color=#c8793c >}} Task

Using `tidyterra` and `ggplot`, produce a map of the elevation profile in the CNP and overlay the spatial point pattern of the Ringlet butterfly occurrence records. Use an appropriate colouring scheme for the elevation values. Do you see any pattern?

`r hide("Take hint")`

You can use the `geom_spatraster()` to add a raster layer to a ggplot object. Furthermore the `scico` library contains a nice range of coloring palettes you can choose, type `scico_palette_show()` to see the color palettes that are available.

`r unhide()`

```{r}
#| fig-width: 5
#| fig-height: 5
#| fig-align: center
#| webex.hide: "Click here to see the solution"
#| code-fold: show
#| purl: false
#| message: false
#| warning: false

library(ggplot2)
library(tidyterra)
library(scico)

ggplot()+ 
  tidyterra::geom_spatraster(data=elev_rast)+
  geom_sf(data=ringlett_CNP,color="white",size=2)+
  geom_sf(data=ringlett_CNP,color="forestgreen",size=1)+
  scale_fill_scico(name = "Elevation (m.a.s.l)",
                   palette = "devon",
                   na.value = "transparent" )

```
:::

### Workflow for Fitting a LGCP model

The procedure for fitting a point process model in `inlabru`, specifically a log-Gaussian Cox process, follows a similar workflow to that of a geostatistical model, these are:

1.  Build the mesh
2.  Define the SPDE representation of the spatial GF. This includes defining the priors for the range and sd of the spatial GF
3.  Define the *components* of the linear predictor. This includes the spatial GF and all eventual covariates.
4. Define the observational model
5. Run the Model

#### Step 1. Building the mesh for a LGCP

First, we need to create the mesh used to approximate the random field. When analyzing point patterns, mesh nodes (integration points) are not typically placed at point locations. Instead, a mesh is created using the `fm_mesh_2d()`function from the `fmesher` library with boundary being our study area.

Key parameters in mesh construction include: `max.edge` for maximum triangle edge lengths, `offset` for inner and outer extensions (to prevent edge effects), and cutoff to avoid overly small triangles in clustered areas.

::: callout-note
**General guidelines for creating the mesh**

1.  Create triangulation meshes with `fm_mesh_2d()`
2.  Move undesired boundary effects away from the domain of interest by extending to a smooth external boundary
3.  Use a coarser resolution in the extension to reduce computational cost (`max.edge=c(inner, outer)`)
4.  Use a fine resolution (subject to available computational resources) for the domain of interest (inner correlation range) and filter out small input point clusters (0 \< `cutoff` \< inner)
5.  Coastlines and similar can be added to the domain specification in `fm_mesh_2d()` through the `boundary` argument.
:::

```{r}
#| fig-width: 4
#| fig-height: 4
#| fig-align: center
# mesh options
max.edge = 2
bound.outer = 10

mesh <- fm_mesh_2d(boundary = shp_SGC,
                   max.edge = c(1,3)*max.edge,
                   offset=c(max.edge, bound.outer),
                   cutoff = 1.5,
                   crs=st_crs(shp_SGC))

ggplot() + gg(mesh) + geom_sf(data=ringlett_CNP)
```

#### Step 2. Defining the SPDE model

We can now define our SPDE model using the `inla.spde2.pcmatern` function. To help us chose some sensible model parameters it is often useful to consider the spatial extension of our study.

```{r}
st_area(shp_SGC)
```

We can use PC-priors for the range $\rho$ and the standard deviation $\sigma$ of the Matérn process

-   Define the prior for the range `prior.range  = (range0,Prange)` $\text{Prob}(\rho<\rho_0) = p_{\rho}$

-   Define the prior for the range `prior.sigma  = (sigma0,Psigma)` $\text{Prob}(\sigma>\sigma_0) = p_{\sigma}$

```{r}
matern <- inla.spde2.pcmatern(mesh,
                              prior.range = c(20, 0.5), # P(range < 20) = 0.5
                              prior.sigma = c(1, 0.5))  # P(sigma > 1) = 0.5
```

Now, for a point process models, the spatial covariates (i.e., the elevation raster) has to be also projected outside the outer mesh for computational purposes. We can achieve this using the following code:

```{r}
#| message: false
#| warning: false
#| fig-width: 4
#| fig-height: 4
#| fig-align: center
library(stars)

# Standardize the raster 
elev_rast <- scale(elev_rast)
# Extend raster ext by a factor of 1.5
re <- extend(elev_rast, ext(elev_rast)*1.5)
# Convert to spatial object
re_df <- re %>% stars::st_as_stars() %>%  st_as_sf(na.rm=F)
# fill in missing values using the original raster 
re_df$GBR_elv_msk <- bru_fill_missing(elev_rast,re_df,re_df$GBR_elv_msk)
# rasterize
elev_rast_p <- stars::st_rasterize(re_df) %>% rast()
# visualize
plot(elev_rast_p)

```

#### Step 3. Defining model components

**Stage 1** Model for the response

The total number of points in the study region is a Poisson random variable with a spatially varying intensity and log-likelihood given by :

$$
l(\beta;s) = \sum_{i=1}^m \log [\lambda(s_i)] - \int_A \lambda(s)ds.
$$

The integral in this expression can be interpreted as the expected number of points in the whole study region. However, the integral of the intensity function has no close form solution and thus we need to approximate it using numerical integration. Luckuly, LGCPs are latent Gaussian models and they may be fitted using INLA.

**Stage 2** Latent field model

We will model the Ringlet distribution as a point process whose intensity function $\lambda(s)$ is additive on the log-scale:

$$
\eta(s) = \log (\lambda(s))= \beta_0 +  \mathbf{x}'(s)\beta + \omega(s),
$$

Here, $\mathbf{x}(s)$ is a set of covariates detected at location $s$ with linear fixed effects $\beta$ to be estimated, and $\omega(s)$ is the Matérn Gaussian field capturing the spatial structure of all the locations where species have been observed (The location where a species occur are assumed to be independent given the Gaussian field).

In this exercise, we will use elevation as our covariate as it seems to be closely related to the distribution of the Ringlet butterfly.

**Stage 3** Hyperparameters

The hyperparameters of the model are $\rho$ and $\sigma$ corresponding to 

$$
\omega(s)\sim \text{  GF with range } \rho\  \text{ and maginal variance }\ \sigma^2
$$

**NOTE** In this case the linear predictor $\eta(s)$ consists of three components.


After the mesh and a SPDE representation of the spatial GF have been defined, the model components can be specified using the formula syntax (recall that this allows users to choose meaningful names for model components).

```{r}
cmp_lgcp <-  geometry ~  Intercept(1)  + 
  elevation(elev_rast_p, model = "linear") +
  grf(geometry, model = matern)
```

Here the labels `Intercept`, `elevation` (elevation effect) and `grf` (an abbreviation of Gaussian random field) are used to name the components of the model but they equally well could be something else.

Now, notice that we have called the `elev_rast_p` raster data within the `elevation` component. Recall that `inlabru`provides support for `sf` and `terra` data structures, allowing it to extract information from spatial data objects. This is particularly relevant for LGCP, as spatial covariates (e.g., the elevation raster) must be available across the whole study area (including the outer mesh).



```{r}
formula = geometry ~ Intercept  + elevation + grf
```

Recall that in an `sf` object, the geo-referenced information of our points is stored in the `geometry` column, and hence we specify this as our response

#### Step 4. Defining th observational model

`inlabru` has support for latent Gaussian Cox processes through the `cp` likelihood family:

```{r}
lik = bru_obs(formula = formula, 
              data = ringlett_CNP, 
              family = "cp",
              samplers = shp_SGC,
              domain = list(geometry = mesh))

```

Notice that we have supplied an `sf` object as our data. LGCPs can be fitted using an `sf` points object to describe the locations of the observed points and an `sf` polygon object to define the observation window (`samplers` in the code above). 


### Step 5. Run the model

Finally, we can fit the model as usual

```{r}
fit_lgcp = bru(cmp_lgcp,lik)
```

Posterior summaries of fixed effects and hyper parameters can be obtained using the `summary()` function.

```{r}
#| eval: false

summary(fit_lgcp)
```

```{r}
#| echo: false
#| purl: false

rbind(fit_lgcp$summary.fixed[,1:6] ,
fit_lgcp$summary.hyperpar )%>% gt() %>% gt::fmt_number(decimals = 2)
```

### Model predictions

Model predictions can be computed using the `predict` function by supplying the coordinates where the covariate is defined. We can do this by defining a `sf` object using coordinates in our original raster data.

```{r}
pxl1 = data.frame(crds(elev_rast), 
                  as.data.frame(elev_rast$GBR_elv_msk)) %>% 
       filter(!is.na(GBR_elv_msk)) %>%
st_as_sf(coords = c("x","y")) %>%
  dplyr::select(-GBR_elv_msk)
```

The formula object for the prediction can be a generic R expression that references model components using the user-defined names.

The `predict()` method returns an object in the same data format as was used in the predict call which, in this case, is an `sf` points object.

Support for plotting `sf` data objects is available in the `ggplot2` package.

::: panel-tabset
# Model predictions

```{r}
#| echo: false
#| purl: false

lgcp_pred <- predict(
  fit_lgcp,
  pxl1,
  ~ data.frame(
    lambda = exp(Intercept + elevation + grf), # intensity
    loglambda = Intercept + elevation +grf,  #log-intensity
    GF = grf # matern field
  )
)

ggplot() +
  gg(lgcp_pred$loglambda, geom = "tile") + 
  scale_fill_viridis(name=expression(log(lambda)))+
  ggplot() +
  gg(lgcp_pred$loglambda, geom = "tile",aes(fill=sd)) + 
  scale_fill_viridis(name=expression(stdev-log(lambda)),option = "B")+
  ggplot() +
  gg(lgcp_pred$lambda, geom = "tile") + scale_fill_viridis(name=expression(lambda))+
  ggplot() +
  gg(lgcp_pred$GF, geom = "tile") + scico::scale_fill_scico(name="Spatial effect")+
  plot_layout(ncol=2)


```

# R Code

```{r}
#| eval: false

lgcp_pred <- predict(
  fit_lgcp,
  pxl1,
  ~ data.frame(
    lambda = exp(Intercept + elevation + grf), # intensity
    loglambda = Intercept + elevation +grf,  #log-intensity
    GF = grf # matern field
  )
)

# predicted log intensity
ggplot() + gg(lgcp_pred$loglambda, geom = "tile") 
# standard deviation of the predicted log intensity
ggplot() + gg(lgcp_pred$loglambda, geom = "tile",aes(fill=sd)) 
# predicted intensity
ggplot() +  gg(lgcp_pred$lambda, geom = "tile") 
# spatial field
ggplot() +  gg(lgcp_pred$GF, geom = "tile") 
```
:::
